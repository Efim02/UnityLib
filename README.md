# UnityLib
My unity lib with architecture solutions. 
Либа с архитектурными решениями для Unity. 

---
## Общее

#### Работа с ошибками
- Исключения, используем только для проверки себя
- Ошибки пользователя обрабатываем, без исключений
- Работаем с обработкой ошибок через GameLogger
- Пишем отказоустойчивый код

#### Постфиксы
- Controller - синглтон на сцене, (живет сцену).
- Manager - синглтон на сцене, (живет игру).
- Model-Service - синглтон. В нашем случае это одно и тоже, т.к. создаются толстые модели, которые необходимы в разработке. (может жить: игру, сцену)
- Moderator - статичный класс с методами и полями.
- Component - подключаемы компонент к игровым объектам.
- Dto - пустая анемичная модель.
- Utils - утилита.
- Worker - живет время выполнения операции.
- Ui - добавляем для объектов являющимися представлениями.

#### Префиксы
- Префикс B_<method_name> в названии метода использование метода кнопкой.
- Префикс E_<method_name> - обозначаем все методы вызываемые-указываемые из GUI.

#### Атрибуты
- SerializeField - используем для указания инициализации-заполнения, в Unity.

#### Наименования тегов TODO
* TODO - Что не обходимо сделать в рамках текущей задачи
* INFUT - Что сделать, если редактирование одного коснется этого участка кода
* ERROR - Была обнаружена ошибка.
* THINK - Мысли-задачи по task-manager.

#### Наименование тегов в Git
- FUTURE - добавил нововведение
- ERROR - исправил ошибку

#### Термины
Server - мастер-клиент, клиент, сервер.
Local - клиент.
Replica - копия объекта, управляемая другим игроком.

#### Пространства имен / Папки

Пример, организации пространства имен / папок;

```
Assembly
├── Models
│   ├── FeautreFolder
│   │   └── FeatureModel.cs
│   │   └── FeatureDto.cs
├── Controllers
│   ├── FeautreFolder1
│   │   └── FeatureModel1.cs
|   |   ...
│   ├── FeatureModel2.cs
├── Utils
├── Extensions
├── Dto
```

В UI и запускающих сборках, может отличаться.

---
## ФИЧИ Architecture

#### Program

- Для инициализации программы реализуем класс BaseProgram  
- Класс Program 

#### MVC

Модель:   
- SingleModel - модель, синглтон

Жизнь:
* Модель - живет:
	- пока ссылаются ```scope```
	- одну сцену ```scene```
	- всю игру ```game```
* Представление - живет:
	- пока ссылаются ```scope```
	- одну сцену ```scene```
	- всю игру ```game```

Представление:
- IView - абстракция представления
- ViewUi - представление с базовой логикой

Подключаемое-представление:
- IAutoView - абстракция представления автоматически подключаемого к модели
- AutoViewUi - представление, автоматически подключаемое
- AutoViewModelConnector - соединитель представлений и моделей, обновляет списки при изменении сцены

Условия: 
+ Создается модель, затем - подключается представление
+ Удаляются ссылки на модель и представления, одновременно. 

Управление:
- ControlUi - содержат код, для взаимодействия с Model

#### Система обновления объектов OUS

Добавлены интерефейсы: ```IStart, IUpdate```.
Контроллер: ```OusController```.
Описание: наследуем от интерфейсов компоненты требующие этих событий, создаем на сцене OusController; синглтон проверяется через Injector.

---
## ФИЧИ Core

#### PHOTON PUN
При построении архитектуры, Client и изменяемый MasterClient.

При разделении логики, стоит использовать два типа воркеров, которые буду работать на двух сторонах;
Воркеры должны подключаться-отключаться после смены статуса игрока;
(Вариант работы через интерефейсы и DI контейнер).

Иначе: приходится писать несколько методов в одном скрипте.

* Нужно создавать абстракцию сервера, которая будет синхронизировать все события между клиентами,
вне зависимости, кто мастер-клиент. Тогда уйдет много геморая с синхронизацией.

* Не хватает слоев абстракций, из-за них код тяжело расширять т.к. измения в одном месте сильно, влияют на другие вещи.

* Нужно добавлять всегда всех имеющихся игроков.
  При входе нового игрока добавлять его. 

* Нужно серверные данные, считывать;
  изменять только через события;
  Не использовать PunMethod для передачи серверных данных, использовать только для игровых объектов и синхронизации их действий 

* Не передавать лишнюю информацию
  Не объединять серверный код с клиентским 

* Сделать две абстракции для событий: PunAbstractEvent - без разделения кода для клиента и сервера, 
  PunAbstractRequestEvent - обработка на сервере, а после обработка на клиенте 
* Вначале игры ожидать доставки всех локальных данных проблематично; поэтому нужно 
  писать код который будет применяться при вызове события, без ошибок

* Слой: Сервер и Клиент и МастерКлиент.
  Сервер можно полностью сериализовать и отправить.
  Клиенты и Мастер клиент взаимодействуют с этими данными только через события.
  События имеют свойство применяться, побочное сохранять информацию.

#### Localizer
Имеется локализитор, который можно использовать для локализации отображаемого текста. Для локализатора написаны утилиты позволяющие проверять все используемые тексты на их наличие,~~~~ в тексте.

---
## ФИЧИ Editor

#### Генераторы и доступные кнопки к ним

###### ControlUi

``` C#
[MenuItem("Игра/Генераторы кода/Создать конфиг")]
[MenuItem("Игра/Генераторы кода/Выбрать конфиг")]
[MenuItem("Игра/Генераторы кода/Проверить и генерировать недостающие контролы")]
[MenuItem("Игра/Генераторы кода/Регенерировать контролы Ui")]
```

###### LabelStorage

``` C#
[MenuItem("Игра/Генераторы Xml/Локализация/Создать файлы")]
[MenuItem("Игра/Генераторы Xml/Локализация/Проверить файлы")]
```

###### Scene

``` C#
[MenuItem("Игра/Карта/Загрузить уровень xxx")]
[MenuItem("Игра/Вернуться на сцену")]  
[MenuItem("Игра/Запустить игру")]
```


